/*
 * Copyright (C) 2024 Dremio
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.projectnessie.catalog.iceberg.httpfileio;

import static java.lang.String.format;
import static java.nio.file.Files.createDirectories;
import static java.nio.file.Files.newByteChannel;
import static java.nio.file.attribute.PosixFilePermission.OWNER_READ;
import static java.nio.file.attribute.PosixFilePermission.OWNER_WRITE;
import static java.nio.file.attribute.PosixFilePermissions.asFileAttribute;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonMap;
import static org.apache.iceberg.relocated.com.google.common.base.Preconditions.checkArgument;
import static org.apache.iceberg.relocated.com.google.common.base.Preconditions.checkState;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;
import java.nio.file.Files;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.PosixFilePermission;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import javax.annotation.Nonnull;
import org.apache.iceberg.io.InputFile;
import org.apache.iceberg.io.SeekableInputStream;
import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Iceberg {@link InputFile} implementation to access files via {@code http(s)}.
 *
 * <p>The HTTP handling is still far away from "production ready". Definitely need to use the Nessie
 * {@code HttpClient} and not {@link URLConnection} here.
 *
 * <p>Supports four different behaviors, depending on the file/response:
 *
 * <ol>
 *   <li>If the server reports a content type that ends with {@code +linear}, each {@link
 *       InputFile#newStream()} issues a separate HTTP GET request. This behavior is intended for
 *       file formats that do not need to "seek", for example Avro <em>newer</em> than spec version
 *       1.2, which has no footer. The manifest-list and manifest-file responses generated by Nessie
 *       Catalog report {@code Content-Type: avro/binary+linear}.
 *   <li>If the server reports that is supports {@code Range} requests (via {@code Accept-Ranges:
 *       bytes}), seeking to the non-current position issues a new HTTP GET request. This is useful
 *       for proxied S3 requests.
 *   <li>If the server reports a HTTP/404 (not found), uses a "non-existing" implementation.
 *   <li>Otherwise an implementation that spills already received data to a temporary file is being
 *       used. Getting the file-length causes the whole file to be retrieved, if the HTTP response
 *       did not include a {@code Content-Length} header.
 * </ol>
 *
 * <p>Future work in/around this class should involve:
 *
 * <ul>
 *   <li>Range-requests not fetching all data, but chunks/blocks of data.
 *   <li>Intelligent range-requests to prefetch relevant parts of the file (magic header + footer).
 * </ul>
 */
final class HttpInputFile implements InputFile {
  private static final Logger LOGGER = LoggerFactory.getLogger(HttpInputFile.class);

  private static final FileAttribute<Set<PosixFilePermission>> SPILL_FILE_PERMISSIONS =
      asFileAttribute(ImmutableSet.of(OWNER_READ, OWNER_WRITE));
  private static final OpenOption[] SPILL_FILE_OPTIONS = {
    StandardOpenOption.CREATE,
    StandardOpenOption.DELETE_ON_CLOSE,
    StandardOpenOption.TRUNCATE_EXISTING,
    StandardOpenOption.READ,
    StandardOpenOption.WRITE
  };

  private final String location;
  private final HttpSource source;

  HttpInputFile(String location, String spillDir) {
    this.location = location;

    HttpSource source;

    URL url;
    try {
      url = new URL(location);
    } catch (MalformedURLException e) {
      throw new IllegalArgumentException("Invalid URL " + location);
    }

    try {
      URLConnection connection = openConnection(url, emptyMap());
      int responseCode = ((HttpURLConnection) connection).getResponseCode();
      if (responseCode == 404) {
        source = new HttpSourceNotExists(location);
      } else if (responseCode >= 200 && responseCode <= 299) {
        long length = connection.getContentLengthLong();
        if (length < 0L) {
          String contentType = connection.getContentType();
          if (contentType != null && contentType.endsWith("+linear")) {
            // no content length, file reading expected w/o seeks
            source = new HttpSourceNonSeekingFakeLength(location, connection);
          } else {
            // no content length, seeking may occur
            source = new HttpSourceSpilling(spillDir, location, -1L, connection);
          }
        } else {
          String acceptRanges = connection.getHeaderField("Accept-Ranges");
          if ("bytes".equals(acceptRanges)) {
            // Server allows `Range` header
            source = new HttpSourceRange(location, length, connection);
          } else {
            // We know the content-length, but cannot perform "seeks" via `Range` header
            source = new HttpSourceSpilling(spillDir, location, length, connection);
          }
        }
      } else {
        throw new RuntimeException(
            "Unexpected HTTP status code "
                + responseCode
                + " accessing "
                + location
                + " : "
                + ((HttpURLConnection) connection).getResponseMessage());
      }
    } catch (IOException e) {
      throw new RuntimeException(e);
    }

    this.source = source;
  }

  static URLConnection openConnection(URL url, Map<String, String> requestHeaders)
      throws IOException {
    URLConnection connection = url.openConnection();
    connection.setDoInput(true);
    connection.setDoOutput(false);
    requestHeaders.forEach(connection::setRequestProperty);
    connection.connect();
    return connection;
  }

  @Override
  public boolean exists() {
    LOGGER.warn("exists() {} ", location);
    return source.exists();
  }

  @Override
  public String location() {
    LOGGER.warn("location() {} ", location);
    return location;
  }

  @Override
  public SeekableInputStream newStream() {
    LOGGER.warn("newStream() {} ", location);
    return source.newStream();
  }

  @Override
  public long getLength() {
    LOGGER.warn("getLength() {} ", location);
    try {
      return source.length();
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  private abstract static class HttpSource {
    final String location;

    HttpSource(String location) {
      this.location = location;
    }

    abstract long length() throws IOException;

    boolean exists() {
      return true;
    }

    abstract SeekableInputStream newStream();
  }

  /** Issues a new HTTP GET using {@code Range} header when seeking. */
  private static final class HttpSourceRange extends HttpSource {
    private final URL url;
    private final long length;
    private URLConnection initial;

    HttpSourceRange(String location, long length, URLConnection initial) {
      super(location);
      this.url = initial.getURL();
      this.length = length;
      this.initial = initial;
    }

    @Override
    long length() {
      return length;
    }

    @Override
    SeekableInputStream newStream() {
      URLConnection conn = initial;
      initial = null;
      try {
        if (conn == null) {
          conn = openConnection(url, emptyMap());
        }
        return new RangeInputStream(conn);
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }

    private final class RangeInputStream extends InputStreamSeekableInput {
      RangeInputStream(URLConnection conn) throws IOException {
        super(conn);
        this.pos = 0L;
      }

      @Override
      public void seek(long newPos) throws IOException {
        if (newPos != pos) {
          URLConnection conn =
              openConnection(url, singletonMap("Range", format("bytes=%d-", newPos)));
          String contentType = conn.getContentType();
          checkState(
              contentType == null || !contentType.startsWith("multipart/"),
              "HTTP multipart response unexpected for single-range request");
          reopen(conn, newPos);
        }
      }
    }
  }

  /**
   * Exposes non-seekable {@link SeekableInputStream}s, when it is expected that consumers will not
   * seek at all, for example for Avro written with spec having no footer, but a header.
   */
  private static final class HttpSourceNonSeekingFakeLength extends HttpSource {
    private final URL url;
    private URLConnection initial;

    HttpSourceNonSeekingFakeLength(String location, URLConnection initial) {
      super(location);
      this.url = initial.getURL();
      this.initial = initial;
    }

    @Override
    long length() {
      return Long.MAX_VALUE;
    }

    @Override
    SeekableInputStream newStream() {
      try {
        URLConnection conn;
        if (initial != null) {
          conn = initial;
          initial = null;
        } else {
          conn = openConnection(url, emptyMap());
        }
        return new HttpBackedNonSeekingInput(conn);
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }

    private static final class HttpBackedNonSeekingInput extends InputStreamSeekableInput {
      HttpBackedNonSeekingInput(URLConnection conn) throws IOException {
        super(conn);
      }

      @Override
      public void seek(long newPos) {
        if (newPos != pos) {
          throw new UnsupportedOperationException(
              "seek not supported for content-types not expected to seek");
        }
      }
    }
  }

  private abstract static class InputStreamSeekableInput extends SeekableInputStream {
    private InputStream delegate;
    protected long pos;

    InputStreamSeekableInput(URLConnection conn) throws IOException {
      this.delegate = conn.getInputStream();
    }

    void reopen(URLConnection conn, long pos) throws IOException {
      this.delegate.close();
      this.delegate = conn.getInputStream();
      this.pos = pos;
    }

    @Override
    public long getPos() {
      return pos;
    }

    @Override
    public int read() throws IOException {
      int r = delegate.read();
      if (r >= 0) {
        pos++;
      }
      return r;
    }

    @Override
    public int read(@Nonnull byte[] b) throws IOException {
      int r = delegate.read(b);
      if (r < 0) {
        return r;
      }
      pos += r;
      return r;
    }

    @Override
    public int read(@Nonnull byte[] b, int off, int len) throws IOException {
      int r = delegate.read(b, off, len);
      if (r < 0) {
        return r;
      }
      pos += r;
      return r;
    }

    @Override
    public void close() throws IOException {
      delegate.close();
    }
  }

  /** Dummy implementation representing a non-existing input-file. */
  private static final class HttpSourceNotExists extends HttpSource {
    HttpSourceNotExists(String location) {
      super(location);
    }

    @Override
    long length() {
      throw new UnsupportedOperationException("IMPLEMENT ME");
    }

    @Override
    boolean exists() {
      return false;
    }

    @Override
    SeekableInputStream newStream() {
      throw new UnsupportedOperationException("IMPLEMENT ME");
    }
  }

  /** Implementation that buffers received data and supports arbitrary seeks. */
  private static final class HttpSourceSpilling extends HttpSource {
    private final String spillDir;
    private URLConnection connection;

    private SeekableByteChannel channel;

    private long readFromRemote;
    private boolean eof;

    private long length;
    private final Lock lock = new ReentrantLock();

    private InputStream httpInput;

    private int refCount = -1;

    HttpSourceSpilling(String spillDir, String location, long length, URLConnection connection) {
      super(location);
      this.spillDir = spillDir;
      this.length = length;
      this.connection = connection;
    }

    private void ensurePresent(long pos) throws IOException {
      if (eof) {
        return;
      }

      checkArgument(pos >= 0L);

      if (channel == null) {
        Path spillFile =
            spillDir(spillDir)
                .resolve("spill-" + ThreadLocalRandom.current().nextLong(0, Long.MAX_VALUE));
        LOGGER.warn("Creating spill file {}", spillFile);
        Files.createFile(spillFile, SPILL_FILE_PERMISSIONS);
        channel = newByteChannel(spillFile, SPILL_FILE_OPTIONS);
        ReferencedCloseables.addCloseable(this, channel);
      }

      if (pos == 0L) {
        return;
      }
      // 16k "block size"
      if ((pos & 0x3fffL) != 0L) {
        pos &= ~0x3fffL;
        pos += 0x4000L;
      }
      if (pos < 0L) {
        pos = Long.MAX_VALUE;
      }

      byte[] buf = new byte[16384];
      ByteBuffer buffer = ByteBuffer.wrap(buf);
      while (!eof) {
        if (readFromRemote < pos) {
          if (httpInput == null) {
            LOGGER.warn("open http input {} ", location);
            httpInput = new BufferedInputStream(connection.getInputStream(), 65536);
            ReferencedCloseables.addCloseable(this, httpInput);
          }

          int rd = readFully(httpInput, buf);
          channel.position(readFromRemote);
          buffer.position(0).limit(rd);
          int wr = 0;
          while (wr < rd) {
            wr += channel.write(buffer);
          }
          readFromRemote += rd;
          LOGGER.warn("buffered up to {} {} ", readFromRemote, location);
          if (eof) {
            length = readFromRemote;
          }
        } else {
          break;
        }
      }
    }

    private int readFully(InputStream input, byte[] buf) throws IOException {
      int remain = buf.length;
      int rd = 0;
      while (remain > 0) {
        int r = input.read(buf, rd, remain);
        if (r < 0) {
          hitEof();
          return rd == 0 ? -1 : rd;
        }
        rd += r;
        remain -= r;
      }
      return rd;
    }

    private void hitEof() throws IOException {
      eof = true;
      LOGGER.warn("buffered everything {} ", location);
      try {
        httpInput.close();
      } finally {
        httpInput = null;
      }
    }

    private Path spillDir(String spillDir) {
      if (spillDir == null) {
        spillDir = System.getProperty("java.io.tmpdir");
      }
      Path dir = Paths.get(spillDir).resolve("nessie-http-files");
      try {
        return createDirectories(dir);
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }

    void reference() {
      lock.lock();
      try {
        if (refCount == -1) {
          refCount = 1;
        } else if (refCount == 0) {
          connection = openConnection(connection.getURL(), emptyMap());
          refCount = 1;
        } else {
          refCount++;
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      } finally {
        lock.unlock();
      }
    }

    void dereference() {
      lock.lock();
      try {
        checkState(refCount > 0);
        refCount--;
        if (refCount == 0) {
          if (httpInput != null) {
            try {
              httpInput.close();
            } catch (IOException e) {
              LOGGER.warn("Failed to close HTTP input", e);
            } finally {
              httpInput = null;
            }
          }
        }
      } finally {
        lock.unlock();
      }
    }

    @Override
    SeekableInputStream newStream() {
      try {
        return new FileBackedSeekableInput(this);
      } finally {
        reference();
      }
    }

    @Override
    long length() throws IOException {
      if (eof || length >= 0L) {
        return length;
      }

      LOGGER.warn("length {}", location);
      lock.lock();
      try {
        ensurePresent(Long.MAX_VALUE);
        return length;
      } finally {
        lock.unlock();
      }
    }

    int read(long pos, byte[] b, int off, int len) throws IOException {
      LOGGER.warn("read, current pos = {}, requested len = {} - {}", pos, len, location);
      checkArgument(pos >= 0);
      checkArgument(off >= 0);
      checkArgument(len >= 0);
      checkArgument(b != null);
      checkArgument(off < b.length);
      checkArgument(off + len <= b.length);
      lock.lock();
      try {
        ensurePresent(pos + len);
        channel.position(pos);
        return channel.read(ByteBuffer.wrap(b, off, len));
      } finally {
        lock.unlock();
      }
    }

    private static final class FileBackedSeekableInput extends SeekableInputStream {
      private final HttpSourceSpilling source;
      private long pos;
      private final AtomicBoolean closed = new AtomicBoolean();
      private final byte[] byteBuffer = new byte[1];

      FileBackedSeekableInput(HttpSourceSpilling source) {
        this.source = source;
      }

      @Override
      public long getPos() {
        assertNotClosed();
        return pos;
      }

      @Override
      public void seek(long newPos) {
        LOGGER.warn("seek to {} {}", newPos, source.location);
        assertNotClosed();
        pos = newPos;
      }

      @Override
      public int read() throws IOException {
        int rd = read(byteBuffer, 0, 1);
        if (rd < 0) {
          return rd;
        }
        pos++;
        int r = byteBuffer[0];
        return r & 0xff;
      }

      @Override
      public int read(@Nonnull byte[] b, int off, int len) throws IOException {
        LOGGER.warn("read {} bytes at {} {}", len, pos, source.location);
        assertNotClosed();
        int rd = source.read(pos, b, off, len);
        if (rd > 0) {
          pos += rd;
        }
        return rd;
      }

      @Override
      public void close() {
        if (closed.compareAndSet(false, true)) {
          LOGGER.warn("close {}", source.location);
          source.dereference();
        }
      }

      private void assertNotClosed() {
        checkState(!closed.get(), "input stream already closed");
      }
    }
  }
}
